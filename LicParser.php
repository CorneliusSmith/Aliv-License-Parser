<html>
<!--
     * File:     LicParser.php
     * Author:   Cornelius Smith III
     * Date:     2019/07/08
     * Purpose:  This program reads in text from a licence file
     *           and extracts all the meaningful information from
     *           it to make copying into an excel spreadsheet easy
     *
     * Notes:    Files MUST have a new line at the start of it. To 
     *           account for any special charachters generated by 
     *           the licence exporter go to the top of the file
     *           place the cursor infront of the first word and 
     *           backspace to the top of the file then press enter
     *           once or twice.
     *           Copyright Â© Cornelius Smith III
     -->
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css">

<!--jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js"></script>

<?php 
// Checks to see what color background the <pre> element should be ensuring
// the background is visible on the main page and then not visible when the
// parsed licences are shown to increase visibility of the data
 if (isset($_POST['LicData'])) 
 {
    $color = "";
 } 
 else{
    $color = "transparent";
 } 
?>  

<style>
body{
   /* background: url("https://www.bealiv.com/img/theme/bg.png");*/
    background: url("https://i.imgur.com/ufwLpOJ.png");
    background-repeat: no-repeat;
    background-size: cover;
    background-position: right;
}
.navbar .navbar-inverse {
  border: none;
}
.navbar-brand {
  padding-top: 5px;
}
.navbar{
  height: 50px;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.navText {
  display : flex;
  justify-content: center;
  color: white;
  font-size: 30px;
  padding-top: 5px;
}
.navTextRight {
  display : flex;
  justify-content: flex-end;
  color: white;
  font-size: 15px;
  margin-top: -40px;
}
.phpCode {
  padding-top: 50px;
  background-color: <?php echo $color?>;
  border-color: transparent;
}
#LicForm{
  width: 60%;
  margin: 0 auto;
  float: none;
}
::placeholder {
  font-size: 20;
}
</style>

<!-- Creates NavBar -->
<head>
    <nav class="navbar navbar-inverse navbar-fixed-top">
        <a class="navbar-brand" href="LicParser.php">
            <img src = "https://www.bealiv.com/img/theme/logo-white.png" height="40">
        </a>
        <div class ="navText">
            <p> License Parser</p>
        </div>
        <div class ="navTextRight">
            <p> By: Cornelius Smith III</p>
        </div>
    </nav>
</head>

<pre class="phpCode" >
<?php
/*
     * Name:        spaceDestroyer
     * Purpose:     To replace 2 or more consecutive whitespace with one 
     *              then trim the whitespace from the left and right end
     *              of a line.
     * Arguments:   The regex statement for whitespace, the line you want
     *              to destroy those spaces from and the whitespace 
     *              characted you want to replace the consecutive space with.
     * Output:      None.
     * Modifies:    The original string.
     * Returns:     The line with the consecutive spaces replaced.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       None.
     */
function spaceDestroyer($regex,$line, $replacement){
    //remove consecutive whitespace from line 
    $line = preg_replace($regex, $replacement, $line);
    //remove whitespace from right and left of the line
    $line = ltrim($line);
    $line = rtrim($line);
    return $line;
}

/*
     * Name:        continueChecker & endChecker 
     * Purpose:     To check whether a line is continue or end to know 
     *              when to switch the neName.
     * Arguments:   The line you want to check.
     * Output:      None.
     * Modifies:    None.
     * Returns:     The the value of strcmp.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       None.
     */
function continueChecker($line){
    return strcmp(trim($line), "To be continued...");
}

function endChecker($line){
    return strcmp(trim($line), "---    END");
}

/*
     * Name:        namePicker 
     * Purpose:     To check whether a line is continue or end to know 
     *              when to switch the neName.
     * Arguments:   The line you want to check.
     * Output:      None.
     * Modifies:    None.
     * Returns:     The the value of strcmp.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       None.
     */
function namePicker($prevLine,$line){
    if (strcmp($prevLine, "NE Name:") === 0) {
        return trim($line);
    }
}

/*
     * Name:        timePicker
     * Purpose:     To get the time the U200 or UGW was checked
     * Arguments:   The line the time should be extracted from.
     * Output:      None.
     * Modifies:    The line.
     * Returns:     The cline trimmed of whitespace to only leave the time.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       None.
     */
function timePicker($line){
    if (strpos($line, "DST") !== false) {
        $line = spaceDestroyer("/\s+/",$line, " ");
        //puts date line into array and get the date from 
        //the length of the array - 2 because the time will
        //always be there when the report is generate. 
        //DST is at the end of the array which would be array
        //length - 1. So time is always infront of DST.
        $arr = explode(" ",$line);
        $time = $arr[count($arr)-2];
        //dumps the array from memory as general house keeping
        //then returns the time.
        $arr = NULL;
        return ($time);
    }
}

/*
     * Name:        readLines
     * Purpose:     To check when to start and stop reading license data 
     * Arguments:   The line, the string to know when to start and the
     *              string to know when to end line.
     * Output:      None.
     * Modifies:    None.
     * Returns:     Whether reading should continue '0' or end '1'
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       None.
     */
function readLines($line,$startLine, $endLine){
    static $reading;
    if (strpos($line, $endLine) === 0){
        return $reading = 1;
    }
    if (strpos($line, $startLine) === 0 || $reading === 0){
        return $reading = 0;
    } 
    return $reading = 1 ;
}

/*
     * Name:        licPopulator
     * Purpose:     To print the license information from a piece of equipment 
     * Arguments:   The neName, time, line, keys and wanted keys.
     * Output:      The wanted keys of a license with the neName and time.
     * Modifies:    The line.
     * Returns:     None.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       None.
     */
function licPopulator($neName,$time,$line,$keys,$wantedKeys){  

    $line = spaceDestroyer("/\s{2,}/",$line, "\t");
    $lineArr = explode("\t", $line);

    if (count($lineArr) == 1){
        return;
    }

    //populates the result array at the index of the associative keys array
    //then prints the neName, the time, and the result array in order of its
    //keys

    for ($i = 0; $i < count($keys); $i++){
        $resultArr[$keys[$i]] = $lineArr[$i];
    }

    echo $neName.','.$time.',';
    for ($i = 0; $i < count($wantedKeys); $i++){

        if ( $i == count($wantedKeys)- 1){
            echo $resultArr[$wantedKeys[$i]];
        }
        else{
            $resultArr[$wantedKeys[$i]] = str_replace(","," ",$resultArr[$wantedKeys[$i]]);
            echo $resultArr[$wantedKeys[$i]].',';
        }
    }
    //var_dump($resultArr); uncomment to see how array is populated

    echo "\n";
    $resultArr = NULL;
    $lineArr = NULL;

}

/*
     * Name:        ensPopulator
     * Purpose:     To print the licence information from the ENS  
     * Arguments:   The neName, time, line, keys and wanted keys.
     * Output:      The wanted keys of a license with the neName and time.
     * Modifies:    The line.
     * Returns:     None.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       This function only exists because the ENS transposes 
     *              columns and rows like everything else, so to save time
     *              by not having a lot of nested if statements the ens 
     *              gets its own function. This can be converted to work
     *              with any future files that are formatted like the ens.
     *              
     */
function ensPopulator($neName,$time,$line,$keys,$wantedKeys){

    $line = spaceDestroyer("/\s{2,}/",$line, "\t");
    $lineArr = explode("\t", $line);
    static $ensCount = 0; //variable to track when to put a new line

    if (count($lineArr) == 1){
        return;
    }

    for ($i = 0; $i < count($keys); $i++){
        $resultArr[$keys[$i]] = $lineArr[$i];
    }

    for ($i = 0; $i < count($wantedKeys); $i++){
        if ( strpos($neName, "ENS") !== false){
            if (strcmp($resultArr[$keys[0]], "License Item") === 0 ||
                strcmp($resultArr[$keys[0]], "Authorization-values") === 0 ||
                strcmp($resultArr[$keys[0]], "Real-values") === 0){
                    if($ensCount == 0){
                        echo $neName.','.$time.',';
                        echo $resultArr[$wantedKeys[$i]].",";
                        $ensCount++;
                    }
                    else if ($ensCount == 3){
                        echo "\n";
                        echo $neName.','.$time.',';
                        echo $resultArr[$wantedKeys[$i]].',';
                        $ensCount = 1;
                    }
                    else{
                        echo $resultArr[$wantedKeys[$i]].",";
                        $ensCount++;
                    }
            }
        }
    }
    $resultArr = NULL;
    $lineArr = NULL;

}

/*
     * Name:        resourceParse - uscdbParse
     * Purpose:     To parse out the wanted information about licenses.  
     * Arguments:   The neName, time, preious line, line.
     * Output:      None.
     * Modifies:    The line.
     * Returns:     None.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       This set of functions first sets up a hard coded associativce  
     *              array with the keys representing the number of columns
     *              you want to take. They are only named to make it easier
     *              to understand when comparing to the files. The
     *              wantedKeys array are is the name of the columns you want.
     *              It then uses the readLines function to know when to start
     *              and stop trying to parse information and while it is parsing
     *              runs licPopulator.
     *              
     */

//used for files formatted like the USN
function resourceParse($neName,$time,$prevLine, $line){
    $resourceKeys = array("Resource Name","Total Resource", "Used Resources");
    $resourceWantedKeys = $resourceKeys;

    if (readLines(trim($prevLine), "Resource","---    END") === 0){
            licPopulator($neName,$time,$line,$resourceKeys,$resourceWantedKeys);
        }
}

//used for files formatted like the HSS
function licUtilizationParse($neName,$time,$prevLine, $line){
    $licUtilKeys = array("License ID", "License Item","Type","Authorization-values","Real-values");
    $licUtilWantedKeys = array("License Item","Authorization-values","Real-values");
    if (readLines(trim($prevLine), "License ID","---    END") === 0){
            licPopulator($neName,$time,$line,$licUtilKeys,$licUtilWantedKeys);
        }
}

//used for files formatted like the cg
function verticalParse($neName,$time,$prevLine, $line){
    //If the dates not being displayed copy the date to the top of the ugw text file.
    $verticalKeys = array("Column 1", "Column 2","Column 3");
    $verticalWantedKeys = array("Column 1", "Column 3");//change key arrays

    if (readLines(trim($prevLine), "-----------------","---    END") === 0){//change start string
        licPopulator($neName,$time,$line,$verticalKeys,$verticalWantedKeys);//change key vars
    }
}

function rncParse($neName,$time,$prevLine, $line){

    $rncKeys = array("Cn Operator Index","Operator Name","License Identifier","License Item","Allocated","Usage");
    $rncWantedKeys = array("License Item","Allocated","Usage");
    if (readLines(trim($prevLine), "Cn Operator Index","---    END") === 0){
            licPopulator($neName,$time,$line,$rncKeys,$rncWantedKeys);
        }
}

function ensParse($neName,$time,$prevLine, $line){  
    //naming scheme is different from the rest because the keys are arbitrary
    //you just need to put in enough keys to grab the information from the line
    //you want. In the other parsers like the usn it was easier to just name 
    //the columns as they were in their respective docs, because the
    //information went horizonally. Due to the ens doc displaying information
    //vertically the key names are just generic colums 1-3 with column 3 being
    //the only key we want to extract information from.

    $ensKeys = array("Column 1", "Column 2","Column 3");
    $ensWantedKeys = array("Column 3");//change key arrays

    if (readLines(trim($prevLine), "License Usage Information","---    END") === 0){//change start string
         ensPopulator($neName,$time,$line,$ensKeys,$ensWantedKeys);//change key vars
     }
}

function ugwParse($neName,$time,$prevLine, $line){
    //If the dates not being displayed copy the date to the top of the ugw text file.
    $ugwKeys = array("Column 1", "Column 2","Column 3");
    $ugwWantedKeys = array("Column 1", "Column 3");//change key arrays

    $neName = trim($neName);
    if (readLines(trim($prevLine), "--------------------------------------------------","---    END") === 0){//change start string
        licPopulator($neName,$time,$line,$ugwKeys,$ugwWantedKeys);//change key vars
    }
}

function uscdbParse($neName,$time,$prevLine, $line){
    $resourceKeys = array("FE Type","Resource","Actual Number", "Maximum Number Allowed");
    $resourceWantedKeys = array("Resource","Actual Number", "Maximum Number Allowed");

    if (readLines(trim($prevLine), "FE type","---    END") === 0){
            licPopulator($neName,$time,$line,$resourceKeys,$resourceWantedKeys);
        }
}


/*
     * Name:        modePicker
     * Purpose:     To pick which the mode and parsing function to use
     * Arguments:   The current line.
     * Output:      None.
     * Modifies:    None.
     * Returns:     The mode.
     * Assumptions: None.
     * Bugs:        None.
     * Notes:       None.
     */
function modePicker($line){
    $mode;
    switch (true){
        case strpos($line, "MMLTask_USN License Utilization") !== false:
            $mode = "RESO";
            break;
        case strpos($line, "MMLTask_HSS License Utilization") !== false:
            $mode = "LIC";
            break;
        case strpos($line, "RNC License Utilization") !== false:
            $mode = "RNC";
            break;
        case strpos($line, "MMLTask_MFRP License Utilization") !== false:
            $mode = "LIC";
            break;
        case strpos($line, "MMLTask_ENS License Utilization") !== false:
            $mode = "ENS";
            break;
        case strpos($line, "display license us") !== false:
            $mode = "UGW";
            break;
        case strpos($line, "MMLTask_SPS License Utilization") !== false:
            $mode = "LIC";
            break;
        case strpos($line, "MMLTask_CSCF License Utilization") !== false:
            $mode = "LIC";
            break;
        case strpos($line, "MMLTask_ATS License Utilization") !== false:
            $mode = "LIC";
            break;
        case strpos($line, "MMLTask_CCF License Utilization") !== false:
            $mode = "LIC";
            break;
        case strpos($line, "MMLTask_MSCServer License Utilization") !== false:
            $mode = "VERT";
            break;
        case strpos($line, "MMLTask_CG License Utilization") !== false:
            $mode = "VERT";
            break;
        case strpos($line, "MMLTask_UPCC License Utilization") !== false:
            $mode = "RESO";
            break;
        case strpos($line, "MMLTask_USCDB License Utilization") !== false:
            $mode = "USCDB";
            break;
        default:
            break;
    } 
    return $mode;
}

if (isset($_POST['LicData'])) 
{
    $type;
    $prevLine;
    $number = 0;
    static $neName;
    static $time;
    $check = 1;
    $lines = strtok($_POST['LicData'],"\n");
    //$time_start = microtime(true);
    //$start_memory = memory_get_usage();
    while ($lines != false)
    {

        //must have new line at start of document
        if (strpos($lines, "++++++ File Name:") !== false || strpos($lines, "display license us") !== false ){
            $type = modePicker($lines);
        }
        switch ($type) {
            case "RESO":
              resourceParse($neName,$time,$prevLine,$lines);
              break;
            case "LIC":
                licUtilizationParse($neName,$time,$prevLine,$lines);
                break;
            case "VERT":
                verticalParse($neName,$time,$prevLine,$lines);
                break;
            case "RNC":
                rncParse($neName,$time,$prevLine,$lines);
                break;
            case "MFRP":
                mfrpParse($neName,$time,$prevLine,$lines);
                break;
            case "ENS":
                ensParse($neName,$time,$prevLine,$lines);
                break;
            case "UGW":
                if ($neName == ""){
                    $neName = explode("-om", $lines);
                    $neName = str_replace("[", "", $neName[0]);
                }
                ugwParse($neName,$time,$prevLine,$lines);
                break;
            case "USCDB":
                uscdbParse($neName,$time,$prevLine,$lines);
                break;
            default:
                break;
        }
        if ($neName == ""){
            $neName = namePicker($prevLine,$lines);
        }
        if ($time == ""){
            $time = timePicker($lines);
        }
        $prevLine = trim($lines);
        $lines = strtok("\n");
        if (continueChecker($lines) === 0){
            $check = 0;
        }
        if (endChecker($lines) === 0){
        //if the end checker sees its the end and the continue variable
        //is true i.e '0' then the neName stays the same. If check is 
        //false i.e '1' then the a new neName is looked for. 
            $number++;
            if ($check == 0){
                readLines($lines,"","---    END");
                $time = "";
                $check = 1;
            }
            else{
                readLines($lines,"","---    END");
                $neName = "";
                $time = "";
            }
        }
    }
    /*$time_end = microtime(true);
    $time_end = $time_end - $time_start;


    echo "\nDid nothing in $time_end seconds\n";

    echo memory_get_usage() - $start_memory;
    echo $number;*/
    die;
}
?>
</pre>
<div class="container-fluid h-100 bg-light text-dark">
    <form action='<?php $_SERVER['PHP_SELF'];?>' method='post' id="LicForm">
        <div class="row justify-content-center">
            <textarea name='LicData' class ="form-control z-depth-1" cols=120 rows=10 placeholder="Paste License Data Here" ></textarea>
             <br>
             <div class="col-md-4 col-md-offset-4 text-center">
             <button type="submit" class="btn btn-raised btn-danger btn-lg" id>Submit</button>
         </div>
    </form>
</div>
</html>

